
// Generated by CodiumAI w changes · https://www.codium.ai/


/*
Generated by CodiumAI · https://www.codium.ai/

Code Analysis:
- The class SimpleGrid is a Three.js grid helper that creates a grid in a scene. It is a component that can be added to a scene and has the ability to be hidden and disposed of.

- The main functionality of the class is to create a grid helper in a Three.js scene.

- The class has a name field that is set to "SimpleGrid" and an enabled field that is set to true.

- The class implements the Hideable and Disposable interfaces.

- The class has a visible getter and setter that allows the grid to be hidden or shown.

- The class has a private _grid field that is a Three.js GridHelper object.

- The class has a private _disposer field that is an instance of the Disposer class.

- The constructor of the class takes a Components object as a parameter and creates a new Three.js GridHelper object with a size of 50 and adds it to the scene.

- The class has a get method that returns the _grid field.

- The class has a dispose method that calls the dispose method of the _disposer field with the _grid field as a parameter.

- The Disposer class is used to dispose of the mesh, its geometry, and its materials from memory. It has a dispose method that takes a mesh, materials, and recursive parameter and removes the mesh from its parent, disposes of its geometry and materials, and recursively disposes of its children. It also has private methods to dispose of the geometry and materials of a mesh and to dispose of its children.
*/

/*
Test Plan:
- test_dispose_mesh: Disposer correctly disposes of the mesh from memory. Tags: [happy path]
- test_dispose_geometry: Disposer correctly disposes of the geometry from memory. Tags: [happy path]
- test_visible_edge: sets the visible property to an edge case (e.g. null) and handles it correctly. Tags: [edge case]
- test_dispose_edge: disposes of a SimpleGrid instance that has already been disposed and handles it correctly. Tags: [edge case]
- test_dispose_material: Disposer correctly disposes of the materials from memory. Tags: [happy path]
- test_dispose_recursive: Disposer correctly disposes of the children of the mesh recursively. Tags: [happy path]
- test_constructor: creates a new instance of SimpleGrid and adds a grid helper to the scene. Tags: [happy path]
- test_get: returns the grid helper correctly. Tags: [happy path]
- test_visible_get: retrieves the visible property correctly. Tags: [happy path]
- test_visible_set: sets the visible property correctly. Tags: [happy path]
- test_dispose: disposes of a SimpleGrid instance and removes the grid helper from the scene. Tags: [happy path]
*/

import { SimpleGrid } from "./index";
import { Disposer } from "../MemoryComponent";
import { BoxGeometry, BufferGeometry, Material, Mesh } from "three";
import { Components } from "../../types";
import {SimpleScene} from "../SimpleScene";

describe('SimpleGrid_class', () => {
  test("test_dispose_mesh", () => {
    const disposer = new Disposer();
    const mesh = new Mesh();
    disposer.dispose(mesh);
    expect(mesh.parent).toBe(null);
    expect(mesh.material).toEqual([]);
    expect(mesh.children.length).toBe(0);
  });

  test("test_dispose_geometry", () => {
    const disposer = new Disposer();
    const geometry = new BufferGeometry();
    disposer.disposeGeometry(geometry);
    expect(geometry.boundsTree).toBe(undefined);
  });

  test("test_visible_edge", () => {
    const components = new Components()
    components.scene = new SimpleScene(components)
    const grid = new SimpleGrid(components);
    expect(() => {
      grid.visible = false
    }).toThrow();
  });

  test("test_dispose_edge", () => {
    const components = new Components()
    components.scene = new SimpleScene(components)
    const grid = new SimpleGrid(components);
    grid.dispose();
    expect(() => {
      grid.dispose()
    }).not.toThrow();
  });

  test("test_dispose_material", () => {
    const disposer = new Disposer();
    const material = new Material();
    const mesh = new Mesh(new BoxGeometry(), material);
    disposer.dispose(mesh);
    expect(() => material.dispose).toHaveBeenCalled();
  });

  test("test_dispose_recursive", () => {
    const disposer = new Disposer();
    const child1 = new Mesh();
    const child2 = new Mesh();
    const mesh = new Mesh();
    mesh.add(child1, child2);
    disposer.dispose(mesh, true, true);
    expect(child1.parent).toBe(null);
  });
})
