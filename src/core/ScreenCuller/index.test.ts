// Generated by CodiumAI

/*
Code Analysis

Main functionalities:
The ScreenCuller class is responsible for culling objects that are not visible
on the screen. It creates a render target and renders the scene to it, then
reads the pixel data to determine which objects are visible. It uses a worker
to process the pixel data and determine which objects are visible, and updates
the visibility of those objects accordingly.

Methods:
- constructor: initializes the class and creates the necessary objects, such as the renderer, render target, and worker.
- dispose: disposes of all resources used by the class, including the renderer, render target, and worker.
- add: adds a mesh to the culling process by creating a new mesh with a unique color and adding it to the scene.
- updateVisibility: updates the visibility of objects based on the pixel data from the render target.

Fields:
- renderer: the WebGLRenderer used to render the scene.
- renderTarget: the WebGLRenderTarget used to render the scene to.
- bufferSize: the size of the buffer used to store pixel data.
- materialCache: a cache of MeshBasicMaterials used to color the meshes.
- worker: the worker used to process the pixel data.
- name: the name of the component.
- enabled: whether the component is enabled or not.
- viewUpdated: an event that is triggered when the visibility of objects is updated.
- needsUpdate: whether the visibility of objects needs to be updated or not.
- meshColorMap: a map of unique colors to meshes.
- renderDebugFrame: whether to render a debug frame or not.
- visibleMeshes: an array of meshes that are currently visible.
- colorMeshes: a map of mesh UUIDs to InstancedMeshes.
- meshes: a map of mesh UUIDs to Meshes.
- _previouslyVisibleMeshes: a set of mesh UUIDs that were previously visible.
- _transparentMat: a transparent MeshBasicMaterial used for transparent meshes.
- _disposer: a Disposer used to dispose of meshes and materials.
- _colors: an object containing the current color values.
- _scene: the scene used to render the meshes.
*/

import * as THREE from "three";
import testComponents from "../../test/mock/testComponents";
import { TestScreenCuller } from "../../test/TestScreenCuller/TestScreenCuller";

const components = testComponents();

const mesh1 = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshBasicMaterial()
);

const mesh2 = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshBasicMaterial()
);

global.Worker = jest.fn().mockImplementation(() => ({
  postMessage: jest.fn(),
  terminate: jest.fn(),
}));

const screenCuller = new TestScreenCuller(components, new Worker("worker"));

describe("ScreenCuller_class", () => {
  // Tests that updating the visibility of meshes updates the visible state of meshes based on the colors returned by the worker.
  it("test_update_visibility", () => {
    components.meshes.push(mesh1, mesh2);
    screenCuller.add(mesh1);
    screenCuller.add(mesh2);
    screenCuller.updateVisibility(true);
    expect(mesh1.visible).toBe(false);
    expect(mesh2.visible).toBe(false);
    screenCuller.renderDebugFrame = true;
    screenCuller.updateVisibility(true);
  });

  // Tests that disposing the ScreenCuller clears all internal data structures.
  it("test_dispose", () => {
    components.meshes.push(mesh1, mesh2);
    screenCuller.add(mesh1);
    screenCuller.add(mesh2);
    screenCuller.dispose();
    expect(screenCuller.enabled).toBe(false);
    expect(screenCuller.meshes.size).toBe(0);
    expect(screenCuller.colorMeshes.size).toBe(0);
    expect(screenCuller.meshColorMap.size).toBe(0);
    expect(screenCuller.visibleMeshes.length).toBe(0);
    expect(screenCuller.materialCache.size).toBe(4);
  });

  // Tests that adding a mesh to ScreenCuller creates a new color mesh and adds it to the scene.
  it("test_add_mesh", () => {
    components.meshes.push(mesh1);
    screenCuller.add(mesh1);
    expect(screenCuller.meshes.size).toBe(0);
    expect(screenCuller.colorMeshes.size).toBe(0);
    expect(screenCuller.meshColorMap.size).toBe(0);
  });
});
