<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="../../../resources/styles.css">
  <link rel="icon" type="image/x-icon" href="../../../resources/favicon.ico">
  <title>Tools Component</title>
</head>
<body>
<div class="full-screen" id="container"></div>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/libs/lil-gui.module.min": "https://unpkg.com/three@0.152.2/examples/jsm/libs/lil-gui.module.min.js",
        "stats.js/src/Stats.js": "https://unpkg.com/stats-js@1.0.1/src/Stats.js",
        "openbim-components": "../../../resources/openbim-components.js"
      }
    }
</script>
<script type="module">

	// Set up scene (see SimpleScene tutorial)

	import Stats from 'stats.js/src/Stats.js';
	import * as THREE from 'three';
	import * as OBC from 'openbim-components';

	// Set up basic components

	const container = document.getElementById('container');

	const components = new OBC.Components();
	const sceneComponent = new OBC.SimpleScene(components);
	components.scene = sceneComponent


	const grid = new OBC.SimpleGrid(components);
	components.tools.add(grid);

	const scene = sceneComponent.get();
	// scene.background = null;

	// Add some lights to the scene

	const directionalLight = new THREE.DirectionalLight();
	directionalLight.position.set(5, 10, 3)
	directionalLight.intensity = 0.5;
	scene.add(directionalLight);

	const ambientLight = new THREE.AmbientLight();
	ambientLight.intensity = 0.5;
	scene.add(ambientLight);

	// Set up postproduction renderer
	components.renderer = new OBC.PostproductionRenderer(components, container);
	components.camera = new OBC.OrthoPerspectiveCamera(components);
	components.raycaster = new OBC.SimpleRaycaster(components);
	components.init();

   components.camera.controls.setLookAt(10, 8, 20, 0, 0, 10);

    /*MD
    ### 🧪 Cool Post-Production Effects
    ---
    Post-production effects enrich your 3D scenes. There are several post-production effects, such as
    adding shadows, rendering outlines, adding ambient occlusion and applying bloom, that can enhance
    and make your scene look cool.🍹

    :::tip First, let's set up a simple scene!

    👀 If you haven't started there, check out [that tutorial first](SimpleScene.mdx)!

    :::

    In this tutorial we will use **Post-Production Renderer** to add neat **Outlines** and **Ambient Occlusion** to the 3D Model.🦾

    ### 🏢 Adding Fragments
    ---
    We'll start by adding a **Fragment** to our scene using Fragment Manager.

    We'll use a simple fragment for the purposes of this tutorial, but the code is capable of handling big files as well.🏗️

    :::info Using Fragment Manager!

    🏋️ There is a dedicated tutorial on how to use Fragment Manager to load **IFC** files!

    :::

    */

    const fragments = new OBC.FragmentManager(components);
    const file = await fetch("../../../resources/small.frag");
    const data = await file.arrayBuffer();
    const buffer = new Uint8Array(data);
    fragments.load(buffer);

	/*MD
	### 🎛️ Setting Up Post-Production
	---
	We'll now set up the post-production, which requires modifying the renderer to use the preferences we've specified.

    Let's start by specifying the outline color, we'll set it to `0x999999`. Also, we will pass the
    camera controls to the post-production object.

	 */

	components.renderer.postproduction.outlineColor = 0x999999;
	components.renderer.postproduction.setup(components.camera.controls);

    /*MD
    ### ❎ Excluding Unwanted Elements
    ---
    At times, we might have to turn off post-production effects for some elements.
    By doing this, the scene is kept clean and unnecessary computation is avoided.🐢

     */

    const gridMesh = grid.get();
    components.renderer.postproduction.excludedItems.add(gridMesh);

    /*MD
    ### 🎬 Activating the Post-Production
    ---

    Now that set up is complete, we wil activate the post-production effect.
    Also, we will enable the visibility for post-production layer.

    - `postproduction.active` - Enable or Disable the active status of the post-processing effect
    - `postproduction.visible` - Toggle the visibility of post-processing layer that is created to display the effect.

     */

	components.renderer.postproduction.active = true;
	components.renderer.postproduction.visible = true;

    /*MD
    ### 🔄 Updating Post-Product Effect
    ---

    Every time the **camera** is changed, we also need to update the post-production effect.🎥
    In order to achieve this, we will write an easy timeout function that will be called after **1000** milliseconds.

    */
	let timeout;
	function updatePostproduction() {
		clearTimeout(timeout);
		components.renderer.postproduction.visible = false;
		timeout = setTimeout(() => {
			components.renderer.postproduction.active = true;
			components.renderer.postproduction.visible = true;
			components.renderer.postproduction.update();
		}, 1000);
    }

    /*MD

    :::tip Timing the Function Execution

    ⏱️ Check out [setTimout](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) for more information on
    how **setTimeout** can be useful when you want to run a function after a certain amount of time!

    :::

    Now, we will invoke the `updatePostproduction` method on mouse events.📢
    The **updatePostproduction** function will be invoked each time a user scrolls to zoom-in or zoom-out and whenever any mouse buttons are pressed.

     */
	window.onwheel = () => updatePostproduction();
	window.onmousedown = () => updatePostproduction();
	window.onmouseup = () => updatePostproduction();

    /*MD
    **Congratulations** 🎉 on completing this tutorial! Now you know how to add cool effects easily using
    Post Production 🖼️
    Let's keep it up and check out another tutorial! 🎓
     */
</script>
</body>
</html>